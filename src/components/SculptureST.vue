<template>
</template>

<script>

import {SculptureST} from '../threejs-sculpture/SculptureST.js';
import {mapGetters} from 'vuex';
import { ShadertoyTexture } from "three-shadertoy-texture";

function defaultMap(obj, id, def) {
  if (obj && obj[id]) {
    return obj[id];
  } else {
    return def;
  }
}

// ogolnie bede probowal tu sie dostac ztego komponentu gdzie trzeba dopasowac kod
// do kodu tego shadera  ktory bedziemy ladowac jak w tamtym projekcietamta biblioteka


//
// const MojTexture = new ShadertoyTexture(1024, 1024);
// MojTexture.image.shader = image;
//
// export const MojExample : ExampleShader = {
//   texture: MojTexture,
//   title: "a",
//   link: "https://www.shadertoy.com/view/cdV3DW",
//   author: "mrange",
//   button: "a"
// }

export default {
  props: ['sculpData', 'sculpPosition'],
  metaInfo() {
    return {
      title: 'Shader Park',
      meta: [
        {property: 'og:title', content: 'Shader Park'},
        {property: 'og:site_name', content: 'Shader Park'},
        // The list of types is available here: http://ogp.me/#types
        {property: 'og:type', content: 'website'},
        // Should the the same as your canonical link, see below.
        // {property: 'og:url', content: 'https://www.my-site.com/my-special-page'},
        {property: 'og:image', content: this.thumbnail},
        // Often the same as your meta description, but not always.
        {property: 'og:description', content: this.title},

        // Twitter card
        {name: 'twitter:card', content: 'summary'},
        // {name: 'twitter:site', content: 'https://www.my-site.com/my-special-page'},
        {name: 'twitter:title', content: 'Shader Park'},
        {name: 'twitter:description', content: this.title},
        // Your twitter handle, if you have one.
        // {name: 'twitter:creator', content: '@alligatorio'},
        {name: 'twitter:image:src', content: this.thumbnail},

        // Google / Schema.org markup:
        {itemprop: 'name', content: 'Shader Park'},
        {itemprop: 'description', content: this.title},
        {itemprop: 'image', content: this.thumbnail}
      ]
    }
  },
  data: function () {
    return {
      //This all gets saved to the Database!!!!
      id: this.sculpData.id || this._uid,
      vueId: this._uid,
      uid: this.sculpData.uid || null,
      username: this.sculpData.username || null,
      title: this.sculpData.title || null,
      isExample: this.sculpData.isExample || false,
      description: this.sculpData.description || null,
      tags: this.sculpData.tags || null,
      timestamp: this.sculpData.timestamp || Date.now(),
      favorites: this.sculpData.favorites || 0,
      views: this.sculpData.views || 0,
      comments: this.sculpData.comments || 0,
      forks: this.sculpData.forks || 0,
      fork: this.sculpData.fork || null, //if a fork set to id
      featured: this.sculpData.featured || false,
      visibility: this.sculpData.visibility || 'public', //draft, public, private
      license: this.sculpData.license || null,
       shaderSource: this.sculpData.shaderSource || `void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = fragCoord/iResolution.xy;
    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));
    fragColor = vec4(col,1.0);
}`,
      type: this.sculpData.type || 'js',
      saved: this.sculpData.shaderSource ? true : false,
      thumbnail: this.sculpData.thumbnail || null,
      //sculptureST is not saved to the db
      sculptureST: null
    };
  },
  mounted() {
    // this.$data = Object.assign(this.$data, this.sculpData);

    // this is just to make a copy??
    let shaderSourceCopy = this.shaderSource.slice();
    this.sculptureST = new SculptureST(true, shaderSourceCopy, null); // Always treat as GLSL for ShaderToy
    if (this.sculptureST.compileError) {
      //wait until the editor opens to log the error
      setTimeout(() => {
        this.$store.commit('setSculptureError', this.sculptureST.compileError);
      }, 300);
    }

    if (this.sculpPosition) {
      this.setPose(this.sculpPosition);
    }
    if (this.id) {
      this.sculptureST.mesh.name = this.id;
    } else {
      this.sculptureST.mesh.name = this._uid; //_uid is a unique ID generated by vue for a component
    }
    window.scene.add(this.sculptureST.mesh);
    this.$store.state.objectsToUpdate.push(this.sculptureST);
    this.$store.state.objectsToRaycast.push(this.sculptureST.mesh);
    this.$store.state.currSculpture = this.$data;
    if (this.$store.state.selectedObject) {
      this.setSelectedSculpture(this.$store.state.selectedObject);
    }
  },
  watch: {
    shaderSource: function (input) {
      if (this.sculptureST) {
        console.log('Updating ShaderToy shader source, length:', input.length);

        try {
          this.sculptureST.refreshMaterial(input);
          this.$store.commit('setSculptureError', ' ');
        } catch (e) {
          this.$store.commit('setSculptureError', e);
        }
      }
    },
    selectedObject: function (obj) {
      this.setSelectedSculpture(obj);
    },
    id: function (val) {
      console.log('id of sculp changed to' + val);
    }
  },
  computed: {
    currUserID() {
      return this.$store.getters.getUser.uid;
    },
    selectedObject() {
      return this.$store.state.selectedObject;
    },

  },
  methods: {
    setPose(pose) {
      this.sculptureST.mesh.position = this.sculpPosition;
    },
    setSaved(saved) {
      this.saved = saved;
    },
    setSelectedSculpture(obj) {
      if (obj && this.sculptureST && this.sculptureST.mesh && this.sculptureST.mesh.name && obj.name == this.sculptureST.mesh.name) {
        this.$store.state.selectedSculpture = this.$data;
        this.$store.state.currSculpture = this.$data;
        this.sculptureST.selectedSculpture(true);
      } else {
        if (this.sculptureST && this.sculptureST.selected) {
          this.sculptureST.selectedSculpture(false);
        }
      }
    },
    removeSculpture() {
      const name = this.id || this._uid;
      this.$store.commit('removeObjectFromUpdate', this.sculptureST);
      this.$store.commit('removeObjectFromRaycast', this.sculptureST.mesh);
      this.$store.commit('removeObjectFromSceneByName', name);
    }
  },
  destroyed: function () {
    this.removeSculpture();
  }
};
</script>
